<meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

Overview
==============================================================


** This is full of errors, omissions and out-of-date stuff.  The header file is the real documentation.**


This is a single file header that implements the most basic *"floating point expansion"* which is where we represent some number by more than one floating-point value. Here using exactly two values and the implementation is limited to double precision. This might also be called *unevaluated pair* or *double-double* arithmetic. This is all TL;DR see the provided references for greater details.

The implementation uses the *C89* feature of passing and returning structures which compilers can handle well since we're limited to two primitive types (logically passed in register) and the code itself is *C99*.  We define two structures:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
typedef struct { double hi,lo; } fe_pair_t;
typedef struct { double hi,lo; } fr_pair_t;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [pairty]: The data types]

\\
The first structure (`fe_pair_t`) is for *standard* floating point expanion which requires 


foo bar baz

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
fe_pair_t fe_pair(double hi, double lo)
fr_pair_t fr_pair(double hi, double lo)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 


testing `uint64_t foo = x;`



The methods work for almost all IEEE style floating-point formats.

1. compiled with no relaxation of floating-point operations. (TODO: need to review if contraction break anything)
2. assumes subnormal (denormals) number support
3. the quoted bounds below will have some limitations on the number of precision bits which vary depending on the algorithm in question. Not any issue for single or double precision but
4. 

[#Muller2021][#LR2019]



Error free transforms (EFT)
==============================================================

Worker routines. These are all error free transforms (EFT).  For fast_sum/diff to be EFT places requirements on the input.

| method            |fops| fma| mul| add| common name   | notes|
| :---------        |---:|:---|:---|---:| :---          |:---  |
| {fe,fr}_fast_sum  | 3  |    |    | 3  | Fast2Sum      |  1   |
| {fe,fr}_fast_diff | 3  |    |    | 3  | Fast2Sum      |  1   |
| {fe,fr}_two_sum   | 6  |    |    | 6  | 2Sum          |      |
| {fe,fr}_two_diff  | 6  |    |    | 6  | 2Sum          |      |
| {fe,fr}_two_mul   | 2  |  1 |  1 |    | 2Prod/2MulFMA |      |


1. $x \pm y$ requires $ \lvert x \lvert \ge \lvert y \lvert $ to be error free.  If the inputs are backwards: 
   $ \lvert x \lvert \lt \lvert y \lvert $ then the error bound is $\lvert h \lvert ~u$ where $h$ is the high result.


[#Fast2Sum]

<details markdown="1"><summary>function list:</summary>

#### EFT functions


  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
fe_pair_t fe_two_mul (double x, double y)
fr_pair_t fr_two_mul (double x, double y)
  
fe_pair_t fe_two_sum (double x, double y)
fr_pair_t fr_two_sum (double x, double y)
fe_pair_t fe_two_diff(double x, double y)
fr_pair_t fr_two_diff(double x, double y)

// require: |x| >= |y|
fe_pair_t fe_fast_sum (double x, double y)
fr_pair_t fr_fast_sum (double x, double y)
fe_pair_t fe_fast_diff(double x, double y)
fr_pair_t fr_fast_diff(double x, double y)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

</details>

Blah
==============================================================


blah

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
fe_pair_t fe_copysign_d(fe_pair_t x, double    n)
fr_pair_t fr_copysign_d(fr_pair_t x, double    n)
fe_pair_t fe_copysign  (fe_pair_t x, fe_pair_t n)
fr_pair_t fr_copysign  (fr_pair_t x, fr_pair_t n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

<br>
Multiplying by a power-of-two value $s$ is simply two products:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
fe_pair_t fe_mul_pot(double s, fe_pair_t x)
fr_pair_t fe_mul_pot(double s, fr_pair_t x)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 




| method            | op                  |
| :---              | :---:               |
| {fe,fr}_copysign  |                     |
|                   |                     |



Arithmetic operations
==============================================================

#### unary

| method         | op           |~bound|fops| div|sqrt| fma| mul| add|common name| notes|
| :---           | :---:        |------|---:|---:|---:|---:|---:|---:| :---      |:---  |
|{fe,fr}_abs     | $\lvert(x)\lvert$    |0     | ~5 |    |    |    |    |    |           |      |
|{fe,fr}_neg     | $-(x)$       |0     |  2 |    |    |    |    |    |           |      |
|{fe,fr}_inv_d   | $1/x$        |0.5   |  3 |  2 |    |  1 |    |    |           |      |
|{fe,fr}_inv_dn  | $1/x$        |1.4587|  3 |  1 |    |  1 |  1 |    |           |      |
|{fe,fr}_inv_dh  | $1/x$        |1.1905|  4 |  1 |    |  2 |  1 |    |           |      |
|                |              |      |    |    |    |    |    |    |           |      |
|{fe,fr}_sqrt    | $\sqrt{(x)}$ |3.0864|  5 |  1 |  1 |  1 |    |  2 |CPairSqrt  |      |
|{fe,fr}_sqrt_d  | $\sqrt{x}$   |0.9982|  4 |  1 |  1 |  1 |    |  1 |CPairSqrt  |      |
|                |              |      |    |    |    |    |    |    |           |      |
| fe_sq          | $(x)^2$      |2.4072|  9 |    |    |  2 |  1 |  6 |           |      |
| fr_sq          | $(x)^2$      |2.9997|  4 |    |    |  2 |  1 |  1 |           |      |
| fe_sq_hq       | $(x)^2$      |1.5   | 15 |    |    |  3 |  2 | 10 |           |      |
|{fe,fr}_sq_d    | $x^2$        |0     |  2 |    |    |  1 |  1 |    |2MulFMA    |      |
|                |              |      |    |    |    |    |    |    |           |      |
|{fe,fr}_rsqrt   | $(x)^{-1/2}$ | 4.894| 18 |  3 |  1 |  3 |  1 | 10 |           | 1    |
|{fe,fr}_rsqrt_s | $(x)^{-1/2}$ |14.453| 18 |  3 |  1 |  3 |  1 | 10 |           |      |
|{fe,fr}_rsqrt_d | $x^{-1/2}$   |5.3630|  7 |  1 |  1 |  3 |  2 |    |           |      |
|{fe,fr}_rsqrt_dh| $x^{-1/2}$   |3.2921|  9 |  1 |  1 |  4 |  3 |    |           |      |

* `{fe,fr}` indicates both are present and have identical implementations
* `(x)`     indicates the input is a pair and `x` is a double
* `num`    in `~bound` is a rough empirical measure in ULP. So relative error is $n\times 2^{-107}$

1. denormal input goes boom


#### binary

| method    | op             |~bound     | error bound   |fops| div|sqrt| fma| mul| add| common name    | notes|
| :---      | :---:          |------     | --------      |---:|---:|---:|---:|---:|---:|  :---          |:---  |
|fe_add     | $(x) + (y)$    |$3u^2-11u^3$| $3u^2+13u^3$ | 20 |    |    |    |    | 20 |AccurateDWPlusDW|      |
|fe_add_s   | $(x) + (y)$    |           | ---           | 11 |    |    |    |    | 11 |SloppyDWPlusDW  |      |
|fe_add_d   | $(x) + y$      |$2u^2-6u^3$| $2u^2$        | 10 |    |    |    |    | 10 |DWPlusFP        |      |
|fe_add_d_cr| $(x) + y$      |           | $u$           | 16 |    |    |    |    | 16 |                | 4    |
|fe_add_dd  | $x + y$        |           | 0             |  6 |    |    |    |    |  6 |2Sum            |      |
|fe_sub     | $(x) - (y)$    |           | $3u^2+13u^3$  | 20 |    |    |    |    | 20 |AccurateDWPlusDW|      |
|fe_sub_s   | $(x) - (y)$    |           | ---           | 11 |    |    |    |    | 11 |SloppyDWPlusDW  |      |
|fe_sub_d   | $(x) - y$      |           | $2u^2$        | 10 |    |    |    |    | 10 |DWPlusFP        |      |
|fe_d_sub   | $x - (y)$      |           | $2u^2$        | 10 |    |    |    |    | 10 |DWPlusFP        |      |
|fe_sub_dd  | $x - y$        |           | 0             |  6 |    |    |    |    |  6 |2Diff           |      |
|fe_mul     | $(x)\times (y)$|$3.997u^2$ | $4u^2$        |  9 |    |    |  3 |  2 |  4 |DWTimesDW3      | 3    |
| ---       | $(x)\times (y)$|$4.985u^2$ | $5u^2$        |    |    |    |  2 |  2 |  7 |DWTimesDW1      | 3    |
| ---       | $(x)\times (y)$|$4.9433u^2$| $5u^2$        | 11 |    |    |  2 |  2 |  7 |DWTimesDW2      | 3    |
|fe_mul_d   | $(x)\times y$  |$1.984u^2$ | $2u^2$        |  6 |    |    |  2 |  1 |  3 |DWTimesFP3      |      |
|fe_mul_da  | $(x)\times y$  | $1.5u^2$  | $1.5u^2+4u^3$ | 10 |    |    |  1 |  2 |  7 |DWTimesFP1      |      |
| ---       | $(x)\times y$  |$2.517u^2$ | $3u^2$        |    |    |    |    |    |    |DWTimesFP2      | 2    |
|fe_mul_dd  | $x\times y$    |           | 0             |  2 |    |    |  1 |  1 |    |2Prod           |      |
|fe_div     | $(x) / (y)$    |$8.665u^2$ | $15u^2+56u^3$ | 14 |  2 |    |  2 |  1 |  9 |DWDivDW2        |      |
|fe_div_a   | $(x) / (y)$    |$5.922u^2$ | $9.8u^2$      | 32 |  1 |    |  6 |  5 | 20 |DWDivDW3        |      |
|fe_div_d   | $(x) / y$      | $2.95u^2$ | $3u^2$        | 10 |  2 |    |  1 |  1 |  6 |DWDivFP3        |      |
| ---       | $(x) / (y)$    |$8.465u^2$ | $15u^2+56u^3$ |    |    |    |    |    |    |DWDivDW1        |      |
|           |                |           |               |    |    |    |    |    |    |                |      |
|fr_add     | $(x) + (y)$    |           | ---           |  8 |    |    |    |    |  8 |CPairSum        |      |
|fr_add_d   | $(x) + y$      |           |               |  4 |    |    |    |    |  4 |CPairSum        |      |
|fr_add_dd  | $x + y$        |           | 0             |  6 |    |    |    |    |  6 |2Sum            |      |
|fr_sub     | $(x) - (y)$    |           | ---           |  8 |    |    |    |    |  8 |CPairSum        |      |
|fr_d_sub   | $x - (y)$      |           | ---           |  7 |    |    |    |    |  7 |CPairSum        |      |
|fr_sub_d   | $(x) - y$      |           | ---           |  7 |    |    |    |    |  7 |CPairSum        |      |
|fr_sub_dd  | $x - y$        |           | 0             |  6 |    |    |    |    |  6 |2Diff           |      |
|fr_mul     | $(x)\times (y)$| $4.9844$  |               |  7 |    |    |    |    |    |CPairMul        |      |
|fr_mul_d   | $(x)\times y$  | $2.0000$  |               |    |    |    |    |    |    |CPairMul        |      |
|fr_mul_dd  | $x\times y$    | 0         | 0             |  2 |    |    |  1 |  1 |    |2Prod           |      |
|fr_div     | $(x) /  (y)$   | $7.0938$  |               |  5 |  2 |    |  1 |  1 |  2 |CPairDiv        |      |
|fr_div_a   | $(x) /  (y)$   | $6.0380$  |               |    |    |    |    |    |    |                |      |



* `method` is the name of the routine. 
* `op` is the arithmetic operation performed where parenthesis (e.g. $\left(x\right)$) indicate a pair and without a `double`
* `~bounds` [#MR2021].  Values without $u^2$ are local empirical measures (other than 0 which is error free)
* `error bounds` are proven values and if rounding mode matters then it's the round-to-nearest ties-to-even. Most results are from "title"[^2].
* `fops` number of floating point ops. exact number is arch specific.
* `common name` is
* `notes`
  1. the function has ordered parameter variant which requires $\lvert x \lvert \ge \lvert y \lvert$. The constraint drops 3 adds and produces identical results. The variant's name prefixes an "o" before the op (e.g. `fe_add` becomes `fe_oadd`)
  2. not implementation. variant w/o FMA or slower & larger error bound.
  3. error bound from "Muller2001"[^1]
  4. fast-path/slow-path method. *fops* is for following fast-path.
  
  
  

Composed ops
==============================================================


| method     | op             |  bound   |fops| div|fma | mul| add| common name     | notes|
| :---       | :---:          | -------- |---:|---:|---:|---:|---:|  :---           |:---  |
| fe_fma_ddd | $a\cdot b +c$  |          | 18 |    |  2 |  1 | 15 |ErrFmaNearest    |      |
|fe_fma_ddd_a| $a\cdot b +c$  |          | 12 |    |  2 |  1 |  9 |ErrFmaApprox     |      |
|            | $         $    |          |    |    |    |    |    |                 |      |
|            | $         $    |          |    |    |    |    |    |                 |      |




Lowering to double and composed lowering functions
==============================================================

\\
blah blah

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
static inline double fe_result(fe_pair_t x) { return x.hi;      }
static inline double fr_result(fr_pair_t x) { return x.hi+x.lo; }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

<br>

foo


| method            | op                  |  bound   |fops| div|fma | mul| add| notes    |
| :---              | :---                | -------- |---:|---:|---:|---:|---:|  :---           |
| fr_result_mul_d   |                     |          |    |    |    |    |    |                 |
| fe_result_mul_d   |                     |          |    |    |    |    |    |                 |
| fe_result_add_d   |                     |          |    |    |    |    |    |                 |
| fe_result_oadd_d  |                     |          |    |    |    |    |    |                 |
| fe_result_roadd_d |                     |          |    |    |    |    |    |                 |




Comparision
==============================================================

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
foo bar baz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 



Double stuff
==============================================================


add3_f64
add3_ro_f64



Triple stuff (foo)
==============================================================

fe_triple_add_pd
fe_triple_fma_ddd



Generic macros
==============================================================


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
foo bar baz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 


Common constants
==============================================================


| name        | value |
| :---        |:---:  |
|fe_k_e       | $e$   |
|fe_k_e_i     | $\frac{1}{e}$ |
|fe_k_log2    | $\text{log}\left(2\right)$ |
|fe_k_log2_i  | $\frac{1}{\text{log}\left(2\right)}$ |
|fe_k_log10   | $\text{log}\left(10\right)$ |
|fe_k_log10_i | $\frac{1}{\text{log}\left(10\right)}$ |
|fe_k_pi      | $\pi$ |
|fe_k_pi_i    | $\frac{1}{\pi}$ |
|fe_k_sqrt_2  | $\sqrt{2}$ |
|fe_k_sqrt_2_i| $\frac{1}{\sqrt{2}}$ |
<br>
**SEE:** [FMA: extended precision addition and multiplication by constant](https://marc-b-reynolds.github.io/math/2020/01/09/ConstAddMul.html) (and references)



Small Examples
==============================================================

#### Known in advance or repeated divisor

If you need to perform a division where the divisor is either known in advance or is used multiple times then it is possible to almost always get a correctly rounded xxx


A 2003 paper [#CrDiv2003] describes 

[post](https://marc-b-reynolds.github.io/math/2019/03/12/FpDiv.html)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c
void array_divide(double* restrict d, double* restrict s, double x, size_t n)
{
  // compute 1/x a double-double
  fe_pair_t r = fe_inv_d(x);

  // tell the compiler we promise n is a non-zero multiple of 16
  if (n == 0 || (n & 0xf) != 0) { __builtin_unreachable(); }

  // d[i] = s[i]/x : correctly rounded ()
  for(size_t i=0; i < n; i++) {
    d[i] = fe_result_mul_d(r,s[i]);
  }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 


blah



----------

References
==============================================================

[#JMP2017]: *"Tight and rigorous error bounds for basic building blocks of double-word arithmetic"*, Joldes, Muller, Popescu, 2017 [(link)](https://hal.science/hal-01351529)

[#MR2021]: *"Formalization of double-word arithmetic, and comments on Tight and rigorous error bounds for basic building blocks of double-word arithmetic"*, Muller & Rideau, 2021 [(link)](https://hal.science/hal-02972245)

[#LR2019]: *"Faithfully rounded floating-point operations"*, M. Lange and S.M. Rump, 2019 [(link)](https://www.tuhh.de/ti3/paper/rump/LaRu2017b.pdf)

[#R2019]:  *"Error bounds for computer arithmetics"*, S.M. Rump, 2019, [(PDF)](https://www.tuhh.de/ti3/paper/rump/Ru19.pdf)

[#CrDiv2003]: *"Accelerating Correctly Rounded Floating-Point Division When the Divisor is Known in Advance"*, Brisebarre, Muller & Raina, 2003 [(link)][https://perso.ens-lyon.fr/jean-michel.muller/fpdiv.html]

[#Fast2Sum]:  *"FastTwoSum revisited"*, Jeannerod & Zimmermann, 2025, [(link)][https://inria.hal.science/hal-04875749]


[^JR2016]: *"On relative errors of floating-point operations: optimal bounds and applications"*, Claude-Pierre Jeannerod, Siegfried M. Rump, 2016 ([PDF](https://hal.inria.fr/hal-00934443))
[^cpj15]:  *"Exploiting structure in floating-point arithmetic"*, Claude-Pierre Jeannerod, 2015 ([PDF]())



<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'none', inlineCodeLang: 'c'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

